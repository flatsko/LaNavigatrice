import React, { useState, useRef, useEffect } from "react";
import jsQR from "jsqr";
import "../../styles/qrscanner.css";

const QRScanner = ({ onScan, onClose }) => {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const streamRef = useRef(null);
  const [isScanning, setIsScanning] = useState(false);
  const [error, setError] = useState(null);
  const [cameraReady, setCameraReady] = useState(false);
  const [cameraFacing, setCameraFacing] = useState("environment");
  const [detectedQR, setDetectedQR] = useState("");
  const [lastScanTime, setLastScanTime] = useState(0);
  const [focusMode, setFocusMode] = useState("continuous");
  const intervalRef = useRef(null);

  useEffect(() => {
    startCamera();
    return () => {
      stopCamera();
    };
  }, [cameraFacing, focusMode]);

  const startCamera = async () => {
    try {
      setError(null);
      setCameraReady(false);

      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error("getUserMedia non support√©");
      }

      // Contraintes optimis√©es pour la cam√©ra arri√®re
      const constraints = [
        // Configuration premium pour cam√©ra arri√®re
        {
          video: {
            facingMode: { exact: cameraFacing },
            width: { ideal: 1920, min: 1280 },
            height: { ideal: 1080, min: 720 },
            focusMode: "continuous",
            exposureMode: "continuous",
            whiteBalanceMode: "continuous",
            zoom: { ideal: 1.0, max: 2.0 },
            // Param√®tres sp√©cifiques pour QR codes
            focusDistance: { ideal: 0.5, min: 0.1, max: 1.0 },
            iso: { ideal: 400, min: 100, max: 1600 },
            brightness: { ideal: 0.1, min: -0.5, max: 0.5 },
            contrast: { ideal: 1.3, min: 0.8, max: 2.0 },
            saturation: { ideal: 0.8, min: 0.5, max: 1.5 },
            sharpness: { ideal: 1.2, min: 0.8, max: 2.0 },
          },
        },
        // Configuration standard
        {
          video: {
            facingMode: cameraFacing,
            width: { ideal: 1280, min: 640 },
            height: { ideal: 720, min: 480 },
            focusMode: "continuous",
            exposureMode: "continuous",
          },
        },
        // Configuration basique
        {
          video: {
            facingMode: cameraFacing,
            width: { ideal: 640 },
            height: { ideal: 480 },
          },
        },
        // Fallback sans facingMode exact
        {
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        },
        // Derni√®re chance
        { video: true },
      ];

      let stream = null;
      let usedConstraint = null;

      for (const constraint of constraints) {
        try {
          console.log("üé• Tentative cam√©ra avec:", constraint);
          stream = await navigator.mediaDevices.getUserMedia(constraint);
          usedConstraint = constraint;
          console.log("‚úÖ Stream obtenu avec:", constraint);
          break;
        } catch (err) {
          console.log("‚ùå √âchec avec:", constraint, err.name);
          continue;
        }
      }

      if (!stream) {
        throw new Error("Impossible d'obtenir le stream cam√©ra");
      }

      streamRef.current = stream;

      // Analyser les capacit√©s de la cam√©ra
      const track = stream.getVideoTracks()[0];
      const capabilities = track.getCapabilities ? track.getCapabilities() : {};
      const settings = track.getSettings ? track.getSettings() : {};

      console.log("üìπ Capacit√©s cam√©ra:", capabilities);
      console.log("‚öôÔ∏è Param√®tres actuels:", settings);

      // Optimiser les param√®tres pour la cam√©ra arri√®re
      if (cameraFacing === "environment" && track.applyConstraints) {
        try {
          const constraints = {};

          // Focus - priorit√© √† la mise au point continue
          if (capabilities.focusMode) {
            if (capabilities.focusMode.includes("continuous")) {
              constraints.focusMode = "continuous";
            } else if (capabilities.focusMode.includes("single-shot")) {
              constraints.focusMode = "single-shot";
            }
          }

          // Distance de focus optimale pour QR codes (environ 20-30cm)
          if (capabilities.focusDistance) {
            constraints.focusDistance = {
              ideal: 0.25, // 25cm
              min: 0.1,
              max: 1.0,
            };
          }

          // Exposition
          if (capabilities.exposureMode?.includes("manual")) {
            constraints.exposureMode = "manual";
            if (capabilities.exposureTime) {
              constraints.exposureTime = {
                ideal: 0.01, // 10ms
                min: 0.005,
                max: 0.02,
              };
            }
          } else if (capabilities.exposureMode?.includes("continuous")) {
            constraints.exposureMode = "continuous";
          }

          // Balance des blancs
          if (capabilities.whiteBalanceMode?.includes("continuous")) {
            constraints.whiteBalanceMode = "continuous";
          }

          // ISO pour r√©duire le bruit
          if (capabilities.iso) {
            constraints.iso = {
              ideal: 200,
              min: 100,
              max: 800,
            };
          }

          // Zoom l√©ger pour am√©liorer la nettet√©
          if (capabilities.zoom) {
            constraints.zoom = {
              ideal: Math.min(1.2, capabilities.zoom.max),
              min: 1.0,
              max: Math.min(2.0, capabilities.zoom.max),
            };
          }

          // Nettet√©
          if (capabilities.sharpness) {
            constraints.sharpness = {
              ideal: 0.8,
              min: 0.5,
              max: 1.0,
            };
          }

          await track.applyConstraints(constraints);
          console.log("‚úÖ Param√®tres optimis√©s appliqu√©s:", constraints);

          // Attendre un peu pour que les param√®tres se stabilisent
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (constraintError) {
          console.log(
            "‚ö†Ô∏è Impossible d'appliquer les contraintes optimis√©es:",
            constraintError
          );
        }
      }

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        videoRef.current.muted = true;
        videoRef.current.playsInline = true;
        videoRef.current.autoplay = true;

        // √âv√©nements pour la cam√©ra arri√®re
        videoRef.current.onloadedmetadata = () => {
          console.log("üìê M√©tadonn√©es charg√©es:", {
            width: videoRef.current.videoWidth,
            height: videoRef.current.videoHeight,
            facing: cameraFacing,
          });
        };

        try {
          await videoRef.current.play();
          console.log("‚ñ∂Ô∏è Lecture vid√©o d√©marr√©e");

          const checkVideoReady = () => {
            if (
              videoRef.current &&
              videoRef.current.videoWidth > 0 &&
              videoRef.current.videoHeight > 0 &&
              videoRef.current.readyState >= 3
            ) {
              console.log("‚úÖ Vid√©o pr√™te pour scan");
              setCameraReady(true);
              setIsScanning(true);

              // D√©lai suppl√©mentaire pour la cam√©ra arri√®re (mise au point)
              setTimeout(
                () => {
                  startScanning();
                },
                cameraFacing === "environment" ? 1000 : 500
              );
            } else {
              console.log("‚è≥ Vid√©o pas encore pr√™te, nouvelle tentative...");
              setTimeout(checkVideoReady, 500);
            }
          };

          setTimeout(checkVideoReady, 200);
        } catch (playError) {
          console.error("‚ùå Erreur lecture vid√©o:", playError);
          setError("Cliquez pour d√©marrer la cam√©ra");
        }
      }
    } catch (err) {
      console.error("‚ùå Erreur cam√©ra compl√®te:", err);
      handleCameraError(err);
    }
  };

  const handleCameraError = (err) => {
    let errorMessage = "Erreur cam√©ra";
    let suggestions = [];

    switch (err.name) {
      case "NotAllowedError":
        errorMessage = "Permission cam√©ra refus√©e";
        suggestions = [
          "Autorisez l'acc√®s √† la cam√©ra",
          "V√©rifiez les param√®tres du navigateur",
          "Rechargez la page",
        ];
        break;
      case "NotFoundError":
        errorMessage = "Cam√©ra non trouv√©e";
        suggestions = [
          "V√©rifiez que votre appareil a une cam√©ra",
          "Essayez de changer de cam√©ra",
          "Red√©marrez l'application",
        ];
        break;
      case "OverconstrainedError":
        errorMessage = "Cam√©ra arri√®re non compatible";
        suggestions = [
          "Votre cam√©ra ne supporte pas les param√®tres demand√©s",
          "Essayez la cam√©ra frontale",
          "Utilisez un autre navigateur",
        ];
        break;
      default:
        errorMessage = err.message || "Erreur inconnue";
        suggestions = [
          "R√©essayez",
          "Changez de cam√©ra",
          "Utilisez la saisie manuelle",
        ];
    }

    setError({ message: errorMessage, suggestions });
    setCameraReady(false);
  };

  const stopCamera = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }

    setIsScanning(false);
    setCameraReady(false);
  };

  // Fonction pour g√©rer la d√©tection QR
  const handleQRDetection = (qrText, now, canvas) => {
    setDetectedQR(qrText);
    setLastScanTime(now);

    // Feedback visuel renforc√© pour cam√©ra arri√®re
    canvas.style.border = "4px solid #00ff00";
    canvas.style.boxShadow = "0 0 20px #00ff00";

    setTimeout(() => {
      if (canvas) {
        canvas.style.border = "none";
        canvas.style.boxShadow = "none";
      }
    }, 800);

    // Vibration plus forte pour cam√©ra arri√®re
    if (navigator.vibrate) {
      navigator.vibrate([200, 100, 200]);
    }

    // D√©lai plus long pour cam√©ra arri√®re (√©viter les faux positifs)
    const triggerDelay = cameraFacing === "environment" ? 1500 : 1000;

    setTimeout(() => {
      console.log("üöÄ D√©clenchement onScan avec:", qrText);
      stopCamera();
      onScan(qrText);
    }, triggerDelay);

    setIsScanning(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  // Scan optimis√© pour cam√©ra arri√®re
  const startScanning = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }

    console.log("üîç D√©marrage scan optimis√© pour", cameraFacing);

    // Fr√©quence adapt√©e selon la cam√©ra
    const scanInterval = cameraFacing === "environment" ? 400 : 300;

    intervalRef.current = setInterval(() => {
      if (
        !videoRef.current ||
        !canvasRef.current ||
        !cameraReady ||
        !isScanning
      ) {
        return;
      }

      try {
        const video = videoRef.current;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");

        if (
          video.readyState < 3 ||
          video.videoWidth === 0 ||
          video.videoHeight === 0
        ) {
          return;
        }

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        // Dessiner l'image de base
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // Am√©lioration de l'image pour la cam√©ra arri√®re
        if (cameraFacing === "environment") {
          // Appliquer des filtres apr√®s le dessin pour la cam√©ra arri√®re
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          // Am√©lioration du contraste et de la luminosit√© pixel par pixel
          for (let i = 0; i < data.length; i += 4) {
            // Convertir en niveaux de gris pour am√©liorer la d√©tection
            const gray =
              0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];

            // Appliquer un seuil adaptatif
            const threshold = gray > 128 ? 255 : 0;

            data[i] = threshold; // Rouge
            data[i + 1] = threshold; // Vert
            data[i + 2] = threshold; // Bleu
            // Alpha reste inchang√©
          }

          ctx.putImageData(imageData, 0, 0);
        }

        // Obtenir les donn√©es d'image apr√®s traitement
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        // Essayer plusieurs approches de d√©tection
        const scanMethods = [
          { inversionAttempts: "attemptBoth" },
          { inversionAttempts: "dontInvert" },
          { inversionAttempts: "onlyInvert" },
        ];

        // Essayer la d√©tection avec l'image trait√©e
        for (const method of scanMethods) {
          const code = jsQR(
            imageData.data,
            imageData.width,
            imageData.height,
            method
          );

          if (code && code.data && code.data.trim()) {
            const qrText = code.data.trim();
            const now = Date.now();

            if (qrText !== detectedQR || now - lastScanTime > 2000) {
              console.log("üéØ QR d√©tect√© avec", cameraFacing, ":", qrText);
              handleQRDetection(qrText, now, canvas);
              return;
            }
          }
        }

        // Pour la cam√©ra arri√®re, essayer aussi avec une r√©solution r√©duite
        if (cameraFacing === "environment") {
          // Cr√©er une version r√©duite pour am√©liorer la d√©tection
          const smallCanvas = document.createElement("canvas");
          const smallCtx = smallCanvas.getContext("2d");
          const scale = 0.7; // Augmenter l√©g√®rement la taille
          smallCanvas.width = canvas.width * scale;
          smallCanvas.height = canvas.height * scale;

          // Redessiner l'image originale (sans traitement) √† une taille r√©duite
          smallCtx.drawImage(
            video,
            0,
            0,
            smallCanvas.width,
            smallCanvas.height
          );

          const smallImageData = smallCtx.getImageData(
            0,
            0,
            smallCanvas.width,
            smallCanvas.height
          );

          // Essayer avec l'image r√©duite
          for (const method of scanMethods) {
            const code = jsQR(
              smallImageData.data,
              smallImageData.width,
              smallImageData.height,
              method
            );

            if (code && code.data && code.data.trim()) {
              const qrText = code.data.trim();
              const now = Date.now();

              if (qrText !== detectedQR || now - lastScanTime > 2000) {
                console.log(
                  "üéØ QR d√©tect√© (image r√©duite) avec",
                  cameraFacing,
                  ":",
                  qrText
                );
                handleQRDetection(qrText, now, canvas);
                return;
              }
            }
          }
        }

        for (const method of scanMethods) {
          const code = jsQR(
            imageData.data,
            imageData.width,
            imageData.height,
            method
          );

          if (code && code.data && code.data.trim()) {
            const qrText = code.data.trim();
            const now = Date.now();

            if (qrText !== detectedQR || now - lastScanTime > 2000) {
              console.log(
                "üéØ QR d√©tect√© (image normale) avec",
                cameraFacing,
                ":",
                qrText
              );
              handleQRDetection(qrText, now, canvas);
              return; // Sortir de la boucle des m√©thodes
            }
          }
        }

        // Nettoyer l'affichage si aucun QR
        const now = Date.now();
        if (detectedQR && now - lastScanTime > 4000) {
          setDetectedQR("");
        }
      } catch (scanError) {
        console.error("‚ùå Erreur scan:", scanError);
      }
    }, scanInterval);
  };

  // Fonction pour forcer la mise au point (cam√©ra arri√®re)
  const forceFocus = async () => {
    if (streamRef.current && cameraFacing === "environment") {
      const track = streamRef.current.getVideoTracks()[0];
      if (track && track.applyConstraints) {
        try {
          // Forcer une nouvelle mise au point
          await track.applyConstraints({
            focusMode: "single-shot",
          });

          setTimeout(async () => {
            await track.applyConstraints({
              focusMode: "continuous",
            });
          }, 1000);

          console.log("üéØ Mise au point forc√©e");
        } catch (err) {
          console.log("‚ö†Ô∏è Impossible de forcer la mise au point:", err);
        }
      }
    }
  };

  const forceStart = async () => {
    if (videoRef.current) {
      try {
        await videoRef.current.play();
        setCameraReady(true);
        setIsScanning(true);
        startScanning();
        setError(null);
      } catch (err) {
        setError("Impossible de d√©marrer la vid√©o");
      }
    }
  };

  const switchCamera = () => {
    const newFacing = cameraFacing === "environment" ? "user" : "environment";
    setCameraFacing(newFacing);
  };

  const handleManualInput = () => {
    const code = prompt("Entrez le code du QR ou l'ID de l'√©nigme:");
    if (code?.trim()) {
      stopCamera();
      onScan(code.trim());
    }
  };

  const handleClose = () => {
    stopCamera();
    onClose();
  };

  const testScan = () => {
    if (!videoRef.current || !canvasRef.current || !cameraReady) {
      alert("‚ùå Cam√©ra non pr√™te. Attendez l'initialisation compl√®te.");
      return;
    }

    const video = videoRef.current;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    // V√©rifier que la vid√©o a des dimensions valides
    if (!video.videoWidth || !video.videoHeight || video.readyState < 3) {
      alert(
        "‚ùå Vid√©o non pr√™te. V√©rifiez que la cam√©ra fonctionne correctement."
      );
      return;
    }

    try {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Appliquer les m√™mes am√©liorations que le scan auto
      if (cameraFacing === "environment") {
        ctx.filter = "contrast(1.3) brightness(1.1) saturate(0.8)";
      }

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.filter = "none";

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const modes = ["attemptBoth", "onlyInvert", "dontInvert"];

      for (const mode of modes) {
        const code = jsQR(imageData.data, imageData.width, imageData.height, {
          inversionAttempts: mode,
        });

        if (code && code.data) {
          console.log(`‚úÖ QR trouv√© avec mode ${mode}:`, code.data);
          alert(
            `‚úÖ QR d√©tect√©: "${code.data}"\nMode: ${mode}\nCam√©ra: ${cameraFacing}`
          );
          onScan(code.data.trim());
          return;
        }
      }

      alert(
        `‚ùå Aucun QR d√©tect√©\nCam√©ra: ${cameraFacing}\nR√©solution: ${canvas.width}x${canvas.height}`
      );
    } catch (error) {
      console.error("Erreur lors du test scan:", error);
      alert(`‚ùå Erreur lors du scan: ${error.message}`);
    }
  };

  return (
    <div className="qr-scanner-overlay">
      <div className="qr-scanner-modal">
        {/* Bouton de fermeture repositionn√© en haut √† droite */}
        <button className="qr-close-btn" onClick={handleClose}>
          ‚úï
        </button>

        <div className="scanner-header">
          <h3>üîç Scanner le QR Code</h3>
        </div>

        <div className="scanner-content">
          {/* Indicateur de cam√©ra active */}

          {/* Affichage du QR d√©tect√© */}
          {detectedQR && (
            <div className="qr-detected-banner">
              <div className="detected-info">
                üéØ <strong>QR d√©tect√©:</strong> {detectedQR}
              </div>
              <div className="auto-trigger-info">
                ‚è±Ô∏è Validation automatique dans{" "}
                {cameraFacing === "environment" ? "1.5" : "1"} seconde...
              </div>
            </div>
          )}

          <div className="camera-container">
            {!cameraReady && !error && (
              <div className="camera-status">
                <div className="loading-spinner"></div>
                <p>
                  {cameraFacing === "environment"
                    ? "Initialisation cam√©ra arri√®re..."
                    : "Initialisation cam√©ra frontale..."}
                </p>
                <button className="force-start-btn" onClick={forceStart}>
                  üé• D√©marrer manuellement
                </button>
              </div>
            )}

            <div
              className="video-container"
              style={{ display: cameraReady ? "block" : "none" }}
            >
              <video
                ref={videoRef}
                className={`camera-video ${cameraFacing}`}
                playsInline
                muted
                style={{
                  width: "100%",
                  height: "auto",
                  maxHeight: "400px",
                  objectFit: "cover",
                  backgroundColor: "#000",
                  // Miroir pour cam√©ra frontale seulement
                  transform: cameraFacing === "user" ? "scaleX(-1)" : "none",
                }}
              />

              <div className="scan-overlay">
                <div className={`scan-frame ${cameraFacing}`}>
                  <div className="scan-corners">
                    <div className="corner top-left"></div>
                    <div className="corner top-right"></div>
                    <div className="corner bottom-left"></div>
                    <div className="corner bottom-right"></div>
                  </div>
                </div>
                {isScanning && (
                  <div className={`scan-line ${cameraFacing}`}></div>
                )}
              </div>
            </div>

            <canvas ref={canvasRef} style={{ display: "none" }} />

            {error && (
              <div className="camera-error">
                <div className="error-icon">üì∑</div>
                <h4>{typeof error === "string" ? error : error.message}</h4>
                {error.suggestions && (
                  <ul className="error-suggestions">
                    {error.suggestions.map((suggestion, index) => (
                      <li key={index}>{suggestion}</li>
                    ))}
                  </ul>
                )}
                <button className="force-start-btn" onClick={forceStart}>
                  üîÑ R√©essayer
                </button>
              </div>
            )}
          </div>

          <div className="scanner-instructions">
            <div className="instruction-content">
              <p>
                {isScanning
                  ? `üîç Scan automatique actif - ${
                      cameraFacing === "environment"
                        ? "Maintenez stable, √©clairage suffisant requis"
                        : "Pointez vers le QR"
                    }`
                  : cameraReady
                  ? "Cam√©ra pr√™te - Scan automatique en cours"
                  : "Initialisation..."}
              </p>
            </div>

            <div className="scanner-actions">
              {!cameraReady && (
                <button className="force-start-btn" onClick={forceStart}>
                  üöÄ Forcer d√©marrage
                </button>
              )}
            </div>

            {/* Contr√¥les de cam√©ra et boutons principaux repositionn√©s en bas */}
            <div className="camera-controls-bottom">
              {/* Contr√¥les de cam√©ra */}
              {cameraReady && (
                <div className="camera-controls">
                  <button className="switch-camera-btn" onClick={switchCamera}>
                    üîÑ Changer cam√©ra (
                    {cameraFacing === "environment" ? "‚Üí Frontale" : "‚Üí Arri√®re"})
                  </button>

                  {cameraFacing === "environment" && (
                    <button className="focus-btn" onClick={forceFocus}>
                      üéØ Forcer mise au point
                    </button>
                  )}
                </div>
              )}
              
              {/* Boutons principaux */}
              <div className="main-buttons">
                {cameraReady && cameraFacing === "environment" && (
                  <button className="test-scan-btn" onClick={testScan}>
                    üì± Scanner QR Code
                  </button>
                )}

                <button className="manual-input-btn" onClick={handleManualInput}>
                  üìù Saisie manuelle
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default QRScanner;
