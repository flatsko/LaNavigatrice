// Syst√®me de points pour La Navigatrice

import { ACHIEVEMENTS } from "../data/achievements.js";

// Configuration des points - SYST√àME √âQUILIBR√â
const POINTS_CONFIG = {
  // === √âNIGMES === (Base du jeu)
  ENIGMA_SOLVED: 200, // Points de base par √©nigme r√©solue
  ENIGMA_PERFECT: 0, // Bonus pour r√©soudre en 1 tentative
  ATTEMPT_PENALTY: 25, // Malus par tentative suppl√©mentaire
  HINT_PENALTY: 30, // P√©nalit√© pour utiliser un indice

  // === MINI-JEUX === (Activit√©s bonus)
  MINIGAME_BASE: {
    morse: 400, // Mini-jeu difficile
    tentacle: 500, // Mini-jeu tr√®s difficile
    sharing: 300, // Mini-jeu social
    compass: 350, // Mini-jeu navigation
  },
  MINIGAME_TIME_MULTIPLIER: 2, // Multiplicateur pour bonus temps

  // === TROPH√âES/ACHIEVEMENTS === (Objectifs √† long terme)
  TROPHY_MOUSSE: 75, // Troph√©es faciles (ex-common)
  TROPHY_MATELOT: 150, // Troph√©es moyens (ex-rare)
  TROPHY_CAPITAINE: 300, // Troph√©es difficiles (ex-epic)
  TROPHY_AMIRAL: 500, // Troph√©es tr√®s difficiles (ex-legendary)
  TROPHY_LEGENDE: 750, // Troph√©es exceptionnels (ex-mythic)

  // === BONUS TEMPS === (R√©compense la rapidit√©)
  TIME_BONUS_PER_MINUTE: 50, // Points par minute √©conomis√©e (augment√© de 15 √† 20)
  TIME_TARGET_MINUTES: 40, // Temps cible pour terminer le jeu
  TIME_BONUS_MAX: 1000, // Bonus maximum possible (augment√© de 600 √† 800)

  // === QUIZ FINAL === (Validation des connaissances)
  QUIZ_PERFECT_BONUS: 200, // Bonus pour 100% au quiz
  QUIZ_GOOD_BONUS: 100, // Bonus pour 80-99% au quiz
  QUIZ_PASS_BONUS: 50, // Bonus pour 60-79% au quiz
};

// Fonction pour calculer les points des √©nigmes
export const calculateEnigmaPoints = (player) => {
  if (!player?.completed || !player?.enigmaAttempts) {
    return { total: 0, details: [] };
  }

  let totalPoints = 0;
  const details = [];

  player.completed.forEach((enigmaId) => {
    const attempts = player.enigmaAttempts[enigmaId] || 1;
    let enigmaPoints = POINTS_CONFIG.ENIGMA_SOLVED;

    // Bonus pour r√©solution parfaite
    if (attempts === 1) {
      enigmaPoints += POINTS_CONFIG.ENIGMA_PERFECT;
    }

    // Malus pour tentatives suppl√©mentaires
    if (attempts > 1) {
      enigmaPoints -= (attempts - 1) * POINTS_CONFIG.ATTEMPT_PENALTY;
    }

    // Minimum 10 points par √©nigme
    enigmaPoints = Math.max(10, enigmaPoints);

    totalPoints += enigmaPoints;
    details.push({
      enigmaId,
      attempts,
      points: enigmaPoints,
      perfect: attempts === 1,
    });
  });

  return { total: totalPoints, details };
};

// Fonction pour calculer les points des mini-jeux
export const calculateMinigamePoints = (minigameResults = []) => {
  let totalPoints = 0;
  const details = [];

  minigameResults.forEach((result) => {
    if (result.skipped) {
      // Aucun point pour les mini-jeux pass√©s
      details.push({
        type: result.gameType || result.type || "unknown",
        success: false,
        points: 0,
        skipped: true,
        reason: "Mini-jeu pass√©",
      });
      return;
    }

    const gameType = result.gameType || result.type || "unknown";

    // Utiliser le score d√©j√† calcul√© par le mini-jeu pour √©viter le double comptage
    let gamePoints = 0;
    if (result.success && result.score !== undefined) {
      gamePoints = result.score; // Utiliser le score calcul√© par le mini-jeu
    } else if (result.success) {
      // Fallback vers l'ancien syst√®me si pas de score fourni
      const basePoints = POINTS_CONFIG.MINIGAME_BASE[gameType] || 300;
      gamePoints = basePoints;

      if (result.timeBonus) {
        const timeBonusPoints = Math.floor(
          result.timeBonus * POINTS_CONFIG.MINIGAME_TIME_MULTIPLIER
        );
        gamePoints += timeBonusPoints;
      }
    }

    totalPoints += gamePoints;
    details.push({
      type: gameType,
      success: result.success,
      points: gamePoints,
      skipped: false,
      originalScore: result.score || 0,
      timeBonus: result.timeBonus || 0,
    });
  });

  return { total: totalPoints, details };
};

// Fonction pour calculer les points des troph√©es
export const calculateTrophyPoints = (player, minigameResults = []) => {
  // R√©cup√©rer les troph√©es d√©bloqu√©s depuis localStorage
  const savedAchievements = JSON.parse(
    localStorage.getItem("playerAchievements") || "[]"
  );

  let totalPoints = 0;
  const details = [];

  savedAchievements.forEach((achievementId) => {
    const achievement = ACHIEVEMENTS.find((a) => a.id === achievementId);
    if (achievement) {
      const points =
        POINTS_CONFIG[`TROPHY_${achievement.rarity.toUpperCase()}`] || 0;
      totalPoints += points;
      details.push({
        id: achievementId,
        rarity: achievement.rarity,
        points,
      });
    }
  });

  return { total: totalPoints, details };
};

// Fonction pour calculer le bonus de temps
export const calculateTimeBonus = (player) => {
  if (!player?.startTime || !player?.lastUpdate) {
    return {
      total: 0,
      details: {
        totalMinutes: 0,
        targetMinutes: POINTS_CONFIG.TIME_TARGET_MINUTES,
        minutesSaved: 0,
        bonusRate: POINTS_CONFIG.TIME_BONUS_PER_MINUTE,
        maxBonus: POINTS_CONFIG.TIME_BONUS_MAX,
      },
    };
  }

  try {
    const startTime = new Date(player.startTime);
    const endTime = new Date(player.lastUpdate);
    const totalMinutes = Math.floor((endTime - startTime) / (1000 * 60));

    let timeBonus = 0;
    let minutesSaved = 0;

    if (totalMinutes < POINTS_CONFIG.TIME_TARGET_MINUTES) {
      minutesSaved = POINTS_CONFIG.TIME_TARGET_MINUTES - totalMinutes;
      timeBonus = minutesSaved * POINTS_CONFIG.TIME_BONUS_PER_MINUTE;

      // Appliquer le plafond maximum
      timeBonus = Math.min(timeBonus, POINTS_CONFIG.TIME_BONUS_MAX);
    }

    return {
      total: Math.max(0, timeBonus),
      details: {
        totalMinutes,
        targetMinutes: POINTS_CONFIG.TIME_TARGET_MINUTES,
        minutesSaved,
        bonusRate: POINTS_CONFIG.TIME_BONUS_PER_MINUTE,
        maxBonus: POINTS_CONFIG.TIME_BONUS_MAX,
        cappedAtMax: timeBonus === POINTS_CONFIG.TIME_BONUS_MAX,
      },
    };
  } catch (error) {
    console.error("Erreur calcul bonus temps:", error);
    return {
      total: 0,
      details: {
        totalMinutes: 0,
        targetMinutes: POINTS_CONFIG.TIME_TARGET_MINUTES,
        minutesSaved: 0,
        bonusRate: POINTS_CONFIG.TIME_BONUS_PER_MINUTE,
        maxBonus: POINTS_CONFIG.TIME_BONUS_MAX,
      },
    };
  }
};

// Fonction pour calculer les p√©nalit√©s d'indices
export const calculateHintPenalties = (player) => {
  // Compter le nombre d'indices utilis√©s depuis l'objet hintsUsed
  const hintsUsedCount = player?.hintsUsed
    ? Object.keys(player.hintsUsed).length
    : 0;

  // Utiliser la p√©nalit√© accumul√©e si elle existe, sinon calculer
  const totalPenalty =
    player?.hintPenalties || hintsUsedCount * POINTS_CONFIG.HINT_PENALTY;

  // Calculer le nombre d'indices bas√© sur la p√©nalit√© r√©elle pour l'affichage
  const displayedHintsUsed = player?.hintPenalties
    ? Math.round(player.hintPenalties / POINTS_CONFIG.HINT_PENALTY)
    : hintsUsedCount;

  return {
    total: totalPenalty,
    details: {
      hintsUsed: displayedHintsUsed,
      penaltyPerHint: POINTS_CONFIG.HINT_PENALTY,
      totalPenalty,
    },
  };
};

// Fonction pour calculer les points du quiz final
export const calculateQuizPoints = (quizScore, totalQuestions) => {
  if (!quizScore || !totalQuestions) {
    return {
      total: 0,
      details: {
        score: 0,
        percentage: 0,
        bonus: 0,
        tier: "none",
      },
    };
  }

  const percentage = (quizScore / totalQuestions) * 100;
  let bonus = 0;
  let tier = "none";

  if (percentage >= 100) {
    bonus = POINTS_CONFIG.QUIZ_PERFECT_BONUS;
    tier = "perfect";
  } else if (percentage >= 80) {
    bonus = POINTS_CONFIG.QUIZ_GOOD_BONUS;
    tier = "good";
  } else if (percentage >= 60) {
    bonus = POINTS_CONFIG.QUIZ_PASS_BONUS;
    tier = "pass";
  }

  return {
    total: bonus,
    details: {
      score: quizScore,
      totalQuestions,
      percentage: Math.round(percentage),
      bonus,
      tier,
    },
  };
};

// Fonction principale pour calculer le score total
export const calculateTotalScore = (
  player,
  minigameResults = [],
  quizScore = null,
  totalQuestions = null
) => {
  const enigmaPoints = calculateEnigmaPoints(player);
  const minigamePoints = calculateMinigamePoints(minigameResults);
  const trophyPoints = calculateTrophyPoints(player, minigameResults);
  const timeBonus = calculateTimeBonus(player);
  const quizPoints = calculateQuizPoints(quizScore, totalQuestions);
  const hintPenalties = calculateHintPenalties(player);

  const totalScore =
    enigmaPoints.total +
    minigamePoints.total +
    trophyPoints.total +
    timeBonus.total +
    quizPoints.total -
    hintPenalties.total;

  return {
    total: Math.max(0, totalScore), // S'assurer que le score ne soit jamais n√©gatif
    breakdown: {
      enigmas: enigmaPoints,
      minigames: minigamePoints,
      trophies: trophyPoints,
      timeBonus: timeBonus,
      quiz: quizPoints,
      hintPenalties: hintPenalties,
    },
  };
};

// Fonction pour obtenir le rang bas√© sur le score
export const getScoreRank = (score) => {
  // Scores ajust√©s pour le nouveau syst√®me (4 √©nigmes √ó 200 = 800 points de base)
  if (score >= 4000)
    return {
      name: "L√©gende Maritime",
      icon: "üëë",
      color: "#FFD700",
      description: "Perfection absolue",
    };
  if (score >= 3200)
    return {
      name: "Amiral des Sept Mers",
      icon: "‚öì",
      color: "#C0392B",
      description: "Excellence remarquable",
    };
  if (score >= 2600)
    return {
      name: "Capitaine Exp√©riment√©",
      icon: "üß≠",
      color: "#8E44AD",
      description: "Ma√Ætrise confirm√©e",
    };
  if (score >= 2000)
    return {
      name: "Navigateur √âm√©rite",
      icon: "‚õµ",
      color: "#2980B9",
      description: "Tr√®s bon niveau",
    };
  if (score >= 1500)
    return {
      name: "Marin Confirm√©",
      icon: "üó∫Ô∏è",
      color: "#27AE60",
      description: "Bon navigateur",
    };
  if (score >= 1000)
    return {
      name: "Explorateur",
      icon: "üåä",
      color: "#F39C12",
      description: "D√©but prometteur",
    };
  if (score >= 500)
    return {
      name: "Apprenti Marin",
      icon: "üêö",
      color: "#95A5A6",
      description: "Premiers pas",
    };
  return {
    name: "Mousse",
    icon: "‚öì",
    color: "#7F8C8D",
    description: "√Ä l'abordage !",
  };
};

// Fonction pour formater l'affichage des points
export const formatScore = (score) => {
  return score.toLocaleString("fr-FR") + " pts";
};

export default {
  calculateEnigmaPoints,
  calculateMinigamePoints,
  calculateTrophyPoints,
  calculateTimeBonus,
  calculateQuizPoints,
  calculateHintPenalties,
  calculateTotalScore,
  getScoreRank,
  formatScore,
  POINTS_CONFIG,
};
