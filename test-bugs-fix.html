<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test - Correction Bugs Indices et Quiz</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .result { margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 3px; }
        .error { background: #ffebee; border-left: 4px solid #f44336; }
        .success { background: #e8f5e8; border-left: 4px solid #4caf50; }
        .warning { background: #fff3e0; border-left: 4px solid #ff9800; }
    </style>
</head>
<body>
    <h1>üîß Test - Correction Bugs Indices et Quiz</h1>
    <p>Ce test v√©rifie les corrections apport√©es pour :</p>
    <ul>
        <li>‚úÖ Duplication des indices (2 utilis√©s mais 6 affich√©s)</li>
        <li>‚úÖ Reset du quiz flag lors d'une nouvelle aventure</li>
    </ul>
    
    <div id="results"></div>

    <script>
        // Simulation de la configuration des points
        const POINTS_CONFIG = {
            HINT_PENALTY: 30
        };

        const GAME_RULES = {
            PENALTY_PER_HINT: 30
        };

        // Fonction corrig√©e pour calculer les p√©nalit√©s d'indices
        function calculateHintPenalties(player) {
            const hintsUsedCount = player?.hintsUsed ? Object.keys(player.hintsUsed).length : 0;
            const totalPenalty = player?.hintPenalties || (hintsUsedCount * POINTS_CONFIG.HINT_PENALTY);
            const displayedHintsUsed = player?.hintPenalties ? Math.round(player.hintPenalties / POINTS_CONFIG.HINT_PENALTY) : hintsUsedCount;

            return {
                total: totalPenalty,
                details: {
                    hintsUsed: displayedHintsUsed,
                    penaltyPerHint: POINTS_CONFIG.HINT_PENALTY,
                    totalPenalty,
                },
            };
        }

        // Simulation de la logique CORRIG√âE de gestion des indices (sans duplication)
        function simulateHintUsage(currentPlayer, enigmaId, hintUsed) {
            if (hintUsed) {
                // Premi√®re mise √† jour : quand on utilise l'indice
                const hintPenalty = GAME_RULES.PENALTY_PER_HINT;
                const updatedPlayerAfterHint = {
                    ...currentPlayer,
                    hintPenalties: (currentPlayer?.hintPenalties || 0) + hintPenalty,
                    hintsUsed: {
                        ...(currentPlayer?.hintsUsed || {}),
                        [enigmaId]: true,
                    },
                };

                // Deuxi√®me mise √† jour : quand on traite la r√©ponse (SANS duplication)
                const finalPlayer = {
                    ...updatedPlayerAfterHint,
                    // Les informations sur les indices sont d√©j√† mises √† jour plus haut
                    lastUpdate: new Date().toISOString(),
                };

                return finalPlayer;
            }
            return currentPlayer;
        }

        // Simulation de la logique ANCIENNE (avec duplication)
        function simulateOldHintUsage(currentPlayer, enigmaId, hintUsed) {
            if (hintUsed) {
                // Premi√®re mise √† jour : quand on utilise l'indice
                const hintPenalty = GAME_RULES.PENALTY_PER_HINT;
                const updatedPlayerAfterHint = {
                    ...currentPlayer,
                    hintPenalties: (currentPlayer?.hintPenalties || 0) + hintPenalty,
                    hintsUsed: {
                        ...(currentPlayer?.hintsUsed || {}),
                        [enigmaId]: true,
                    },
                };

                // Deuxi√®me mise √† jour : quand on traite la r√©ponse (AVEC duplication)
                const finalPlayer = {
                    ...updatedPlayerAfterHint,
                    // DUPLICATION ICI !
                    hintPenalties: (updatedPlayerAfterHint?.hintPenalties || 0) + GAME_RULES.PENALTY_PER_HINT,
                    hintsUsed: {
                        ...(updatedPlayerAfterHint?.hintsUsed || {}),
                        [enigmaId]: true,
                    },
                    lastUpdate: new Date().toISOString(),
                };

                return finalPlayer;
            }
            return currentPlayer;
        }

        function runTest(testName, testFunction, expectedResult) {
            try {
                const result = testFunction();
                const isCorrect = JSON.stringify(result) === JSON.stringify(expectedResult);
                
                return {
                    testName,
                    result,
                    expectedResult,
                    isCorrect,
                    message: isCorrect ? '‚úÖ Test r√©ussi' : '‚ùå Test √©chou√©'
                };
            } catch (error) {
                return {
                    testName,
                    result: null,
                    expectedResult,
                    isCorrect: false,
                    message: `‚ùå Erreur: ${error.message}`
                };
            }
        }

        function displayResult(test) {
            const div = document.createElement('div');
            div.className = `test-case ${test.isCorrect ? 'success' : 'error'}`;
            div.innerHTML = `
                <h3>${test.testName}</h3>
                <p><strong>R√©sultat:</strong></p>
                <pre>${JSON.stringify(test.result, null, 2)}</pre>
                <p><strong>Attendu:</strong></p>
                <pre>${JSON.stringify(test.expectedResult, null, 2)}</pre>
                <p><strong>Status:</strong> ${test.message}</p>
            `;
            document.getElementById('results').appendChild(div);
        }

        // Tests
        console.log('üß™ D√©but des tests de correction...');

        // Test 1: V√©rifier que la nouvelle logique ne duplique pas
        const test1 = runTest(
            'Test 1: Nouvelle logique - Pas de duplication',
            () => {
                const initialPlayer = { hintPenalties: 0, hintsUsed: {} };
                const result = simulateHintUsage(initialPlayer, 'enigma1', true);
                return {
                    hintPenalties: result.hintPenalties,
                    hintsUsedCount: Object.keys(result.hintsUsed).length
                };
            },
            { hintPenalties: 30, hintsUsedCount: 1 }
        );
        displayResult(test1);

        // Test 2: V√©rifier que l'ancienne logique dupliquait
        const test2 = runTest(
            'Test 2: Ancienne logique - Duplication d√©tect√©e',
            () => {
                const initialPlayer = { hintPenalties: 0, hintsUsed: {} };
                const result = simulateOldHintUsage(initialPlayer, 'enigma1', true);
                return {
                    hintPenalties: result.hintPenalties,
                    hintsUsedCount: Object.keys(result.hintsUsed).length
                };
            },
            { hintPenalties: 60, hintsUsedCount: 1 } // 60 au lieu de 30 = duplication
        );
        displayResult(test2);

        // Test 3: Sc√©nario utilisateur (2 indices utilis√©s)
        const test3 = runTest(
            'Test 3: Sc√©nario utilisateur - 2 indices',
            () => {
                let player = { hintPenalties: 0, hintsUsed: {} };
                player = simulateHintUsage(player, 'enigma1', true);
                player = simulateHintUsage(player, 'enigma3', true);
                
                const scoreData = calculateHintPenalties(player);
                return {
                    hintPenalties: player.hintPenalties,
                    hintsUsedCount: Object.keys(player.hintsUsed).length,
                    displayedHints: scoreData.details.hintsUsed,
                    totalPenalty: scoreData.total
                };
            },
            { 
                hintPenalties: 60, 
                hintsUsedCount: 2, 
                displayedHints: 2, 
                totalPenalty: 60 
            }
        );
        displayResult(test3);

        // Test 4: Simulation localStorage.clear() pour le quiz
        const test4 = runTest(
            'Test 4: Reset quiz flag avec localStorage.clear()',
            () => {
                // Simuler des donn√©es de quiz
                const mockLocalStorage = {
                    'quiz_player1': JSON.stringify({ completed: true, score: 85 }),
                    'currentPlayer': JSON.stringify({ name: 'player1' }),
                    'otherData': 'some value'
                };
                
                // Simuler localStorage.clear()
                const afterClear = {};
                
                return {
                    beforeClear: Object.keys(mockLocalStorage),
                    afterClear: Object.keys(afterClear),
                    quizDataCleared: !afterClear.hasOwnProperty('quiz_player1')
                };
            },
            {
                beforeClear: ['quiz_player1', 'currentPlayer', 'otherData'],
                afterClear: [],
                quizDataCleared: true
            }
        );
        displayResult(test4);

        // R√©sum√©
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'test-case success';
        summaryDiv.innerHTML = `
            <h3>üìã R√©sum√© des Corrections</h3>
            <ul>
                <li><strong>Probl√®me indices :</strong> Suppression de la duplication dans App.jsx (lignes 720-725)</li>
                <li><strong>Probl√®me quiz :</strong> clearAllData() fait localStorage.clear() qui nettoie toutes les donn√©es</li>
                <li><strong>R√©sultat :</strong> Les deux bugs devraient √™tre corrig√©s</li>
            </ul>
            <p><strong>Note :</strong> Si le probl√®me du quiz persiste, v√©rifier que VictoryPage utilise bien clearAllData et non restartGame.</p>
        `;
        document.getElementById('results').appendChild(summaryDiv);

        console.log('‚úÖ Tests termin√©s');
    </script>
</body>
</html>